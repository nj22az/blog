import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import { getImageDimensions } from "@sanity/asset-utils";
import imageUrlBuilder from "@sanity/image-url";
import { Card, Text, Tooltip, Box, Stack, Flex } from "@sanity/ui";
import { randomKey } from "@sanity/util/content";
import { get } from "lodash-es";
import { useState, useEffect, useCallback, createElement, useRef, useMemo } from "react";
import { useClient, useFormValue, useResolveInitialValueForType, PatchEvent, setIfMissing, insert, set, definePlugin } from "sanity";
import { useMotionValue, motion } from "framer-motion";
function Feedback({ children }) {
  return /* @__PURE__ */ jsx(Card, { padding: 4, radius: 2, shadow: 1, tone: "caution", children: /* @__PURE__ */ jsx(Text, { children }) });
}
const dragStyle = {
  width: "1.4rem",
  height: "1.4rem",
  position: "absolute",
  boxSizing: "border-box",
  top: 0,
  left: 0,
  margin: "-0.7rem 0 0 -0.7rem",
  cursor: "pointer",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "50%",
  background: "#000",
  color: "white"
}, dragStyleWhileDrag = {
  background: "rgba(0, 0, 0, 0.1)",
  border: "1px solid #fff",
  cursor: "none"
}, dragStyleWhileHover = {
  background: "rgba(0, 0, 0, 0.1)",
  border: "1px solid #fff"
}, dotStyle = {
  position: "absolute",
  left: "50%",
  top: "50%",
  height: "0.2rem",
  width: "0.2rem",
  margin: "-0.1rem 0 0 -0.1rem",
  background: "#fff",
  visibility: "hidden",
  borderRadius: "50%",
  // make sure pointer events only run on the parent
  pointerEvents: "none"
}, dotStyleWhileActive = {
  visibility: "visible"
}, labelStyle = {
  color: "white",
  fontSize: "0.7rem",
  fontWeight: 600,
  lineHeight: "1"
}, labelStyleWhileActive = {
  visibility: "hidden"
}, round = (num) => Math.round(num * 100) / 100;
function Spot({
  value,
  bounds,
  update,
  hotspotDescriptionPath,
  tooltip,
  index,
  schemaType,
  renderPreview
}) {
  const [isDragging, setIsDragging] = useState(!1), [isHovering, setIsHovering] = useState(!1), x = useMotionValue(round(bounds.width * (value.x / 100))), y = useMotionValue(round(bounds.height * (value.y / 100)));
  useEffect(() => {
    x.set(round(bounds.width * (value.x / 100))), y.set(round(bounds.height * (value.y / 100)));
  }, [x, y, value, bounds]);
  const handleDragEnd = useCallback(() => {
    setIsDragging(!1);
    const currentX = x.get(), currentY = y.get(), newX = round(currentX * 100 / bounds.width), newY = round(currentY * 100 / bounds.height), safeX = Math.max(0, Math.min(100, newX)), safeY = Math.max(0, Math.min(100, newY));
    update(value._key, safeX, safeY);
  }, [x, y, value, update, bounds]), handleDragStart = useCallback(() => setIsDragging(!0), []), handleHoverStart = useCallback(() => setIsHovering(!0), []), handleHoverEnd = useCallback(() => setIsHovering(!1), []);
  return !x || !y ? null : /* @__PURE__ */ jsx(
    motion.div,
    {
      drag: !0,
      dragConstraints: bounds,
      dragElastic: 0,
      dragMomentum: !1,
      onDragEnd: handleDragEnd,
      onDragStart: handleDragStart,
      onHoverStart: handleHoverStart,
      onHoverEnd: handleHoverEnd,
      style: {
        ...dragStyle,
        x,
        y,
        ...isDragging && { ...dragStyleWhileDrag },
        ...isHovering && { ...dragStyleWhileHover }
      },
      children: /* @__PURE__ */ jsx(
        Tooltip,
        {
          disabled: isDragging,
          portal: !0,
          content: tooltip && typeof tooltip == "function" ? createElement(tooltip, { value, renderPreview, schemaType }) : /* @__PURE__ */ jsx(Box, { padding: 2, style: { maxWidth: 200, pointerEvents: "none" }, children: /* @__PURE__ */ jsx(Text, { textOverflow: "ellipsis", children: hotspotDescriptionPath ? get(value, hotspotDescriptionPath) : `${value.x}% x ${value.y}%` }) }),
          children: /* @__PURE__ */ jsxs("div", { children: [
            /* @__PURE__ */ jsx(
              Box,
              {
                style: {
                  ...dotStyle,
                  ...(isDragging || isHovering) && { ...dotStyleWhileActive }
                }
              }
            ),
            /* @__PURE__ */ jsx(
              "div",
              {
                style: {
                  ...labelStyle,
                  ...(isDragging || isHovering) && { ...labelStyleWhileActive }
                },
                children: index + 1
              }
            )
          ] })
        },
        value._key
      )
    }
  );
}
function useUnmountEffect(effect) {
  const effectRef = useRef(effect);
  effectRef.current = effect, useEffect(() => () => effectRef.current(), []);
}
function useDebouncedCallback(callback, deps, delay, maxWait = 0) {
  const timeout = useRef(), waitTimeout = useRef(), cb = useRef(callback), lastCall = useRef(), clear = () => {
    timeout.current && (clearTimeout(timeout.current), timeout.current = void 0), waitTimeout.current && (clearTimeout(waitTimeout.current), waitTimeout.current = void 0);
  };
  return useUnmountEffect(clear), useEffect(() => {
    cb.current = callback;
  }, deps), useMemo(() => {
    const execute = () => {
      if (clear(), !lastCall.current)
        return;
      const context = lastCall.current;
      lastCall.current = void 0, cb.current.apply(context.this, context.args);
    }, wrapped = function(...args) {
      timeout.current && clearTimeout(timeout.current), lastCall.current = { args, this: this }, timeout.current = setTimeout(execute, delay), maxWait > 0 && !waitTimeout.current && (waitTimeout.current = setTimeout(execute, maxWait));
    };
    return Object.defineProperties(wrapped, {
      length: { value: callback.length },
      name: { value: `${callback.name || "anonymous"}__debounced__${delay}` }
    }), wrapped;
  }, [delay, maxWait, ...deps]);
}
const isBrowser = typeof window < "u" && typeof navigator < "u" && typeof document < "u";
let observerSingleton;
function getResizeObserver() {
  if (!isBrowser)
    return;
  if (observerSingleton)
    return observerSingleton;
  const callbacks = /* @__PURE__ */ new Map(), observer = new ResizeObserver((entries) => {
    var _a;
    for (const entry of entries)
      (_a = callbacks.get(entry.target)) == null || _a.forEach(
        (cb) => setTimeout(() => {
          cb(entry);
        }, 0)
      );
  });
  return observerSingleton = {
    observer,
    subscribe(target, callback) {
      let cbs = callbacks.get(target);
      cbs || (cbs = /* @__PURE__ */ new Set(), callbacks.set(target, cbs), observer.observe(target)), cbs.add(callback);
    },
    unsubscribe(target, callback) {
      const cbs = callbacks.get(target);
      cbs && (cbs.delete(callback), cbs.size === 0 && (callbacks.delete(target), observer.unobserve(target)));
    }
  }, observerSingleton;
}
function useResizeObserver(target, callback, enabled = !0) {
  const ro = enabled && getResizeObserver(), cb = useRef(callback);
  cb.current = callback;
  const tgt = target && "current" in target ? target.current : target;
  useEffect(() => {
    const _tgt = target && "current" in target ? target.current : target;
    if (!ro || !_tgt)
      return;
    let subscribed = !0;
    const handler = (...args) => {
      subscribed && cb.current(...args);
    };
    return ro.subscribe(_tgt, handler), () => {
      subscribed = !1, ro.unsubscribe(_tgt, handler);
    };
  }, [tgt, ro]);
}
const imageStyle = { width: "100%", height: "auto" }, VALID_ROOT_PATHS = ["document", "parent"];
function ImageHotspotArray(props) {
  var _a;
  const { value, onChange, imageHotspotOptions, schemaType, renderPreview } = props, sanityClient = useClient({ apiVersion: "2022-01-01" }), imageHotspotPathRoot = useMemo(() => {
    var _a2;
    return (VALID_ROOT_PATHS.includes((_a2 = imageHotspotOptions.pathRoot) != null ? _a2 : "") ? imageHotspotOptions.pathRoot : "document") === "document" ? [] : props.path.slice(0, -1);
  }, [imageHotspotOptions.pathRoot, props.path]), rootObject = useFormValue(imageHotspotPathRoot), resolveInitialValueForType = useResolveInitialValueForType(), resolveInitialValue = useCallback(
    async (type) => resolveInitialValueForType(type, {}).then((initialValue) => initialValue).catch(() => {
    }),
    [resolveInitialValueForType]
  ), hotspotImage = useMemo(() => imageHotspotOptions.imagePath ? get(rootObject, imageHotspotOptions.imagePath) : rootObject, [rootObject, imageHotspotOptions.imagePath]), displayImage = useMemo(() => {
    var _a2, _b;
    const builder = imageUrlBuilder(sanityClient).dataset((_a2 = sanityClient.config().dataset) != null ? _a2 : ""), urlFor = (source) => builder.image(source);
    if ((_b = hotspotImage == null ? void 0 : hotspotImage.asset) != null && _b._ref) {
      const { aspectRatio } = getImageDimensions(hotspotImage.asset._ref), width = 1200, height = Math.round(width / aspectRatio), url = urlFor(hotspotImage).width(width).url();
      return { width, height, url };
    }
    return null;
  }, [hotspotImage, sanityClient]), handleHotspotImageClick = useCallback(
    async (event) => {
      const { nativeEvent, currentTarget } = event, x = Number((nativeEvent.offsetX * 100 / currentTarget.width).toFixed(2)), y = Number((nativeEvent.offsetY * 100 / currentTarget.height).toFixed(2)), description = `New Hotspot at ${x}% x ${y}%`, initialValues = await resolveInitialValue(schemaType.of[0].type), newRow = {
        _key: randomKey(12),
        _type: schemaType.of[0].name,
        ...initialValues,
        x,
        y
      };
      imageHotspotOptions != null && imageHotspotOptions.descriptionPath && (newRow[imageHotspotOptions.descriptionPath] = description), onChange(PatchEvent.from([setIfMissing([]), insert([newRow], "after", [-1])]));
    },
    [imageHotspotOptions, onChange, resolveInitialValue, schemaType]
  ), handleHotspotMove = useCallback(
    (key, x, y) => {
      onChange(
        PatchEvent.from([
          // Set the `x` value of this array key item
          set(x, [{ _key: key }, "x"]),
          // Set the `y` value of this array key item
          set(y, [{ _key: key }, "y"])
        ])
      );
    },
    [onChange]
  ), hotspotImageRef = useRef(null), [imageRect, setImageRect] = useState();
  return useResizeObserver(
    hotspotImageRef,
    useDebouncedCallback(
      (e) => setImageRect(e.contentRect),
      [setImageRect],
      200
    )
  ), /* @__PURE__ */ jsxs(Stack, { space: [2, 2, 3], children: [
    displayImage != null && displayImage.url ? /* @__PURE__ */ jsxs("div", { style: { position: "relative" }, children: [
      imageRect && ((_a = value == null ? void 0 : value.length) != null ? _a : 0) > 0 && (value == null ? void 0 : value.map((spot, index) => /* @__PURE__ */ jsx(
        Spot,
        {
          index,
          value: spot,
          bounds: imageRect,
          update: handleHotspotMove,
          hotspotDescriptionPath: imageHotspotOptions == null ? void 0 : imageHotspotOptions.descriptionPath,
          tooltip: imageHotspotOptions == null ? void 0 : imageHotspotOptions.tooltip,
          renderPreview,
          schemaType: schemaType.of[0]
        },
        spot._key
      ))),
      /* @__PURE__ */ jsx(Card, { __unstable_checkered: !0, shadow: 1, children: /* @__PURE__ */ jsx(Flex, { align: "center", justify: "center", children: /* @__PURE__ */ jsx(
        "img",
        {
          ref: hotspotImageRef,
          src: displayImage.url,
          width: displayImage.width,
          height: displayImage.height,
          alt: "",
          style: imageStyle,
          onClick: handleHotspotImageClick
        }
      ) }) })
    ] }) : /* @__PURE__ */ jsx(Feedback, { children: imageHotspotOptions.imagePath ? /* @__PURE__ */ jsxs(Fragment, { children: [
      "No Hotspot image found at path ",
      /* @__PURE__ */ jsx("code", { children: imageHotspotOptions.imagePath })
    ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
      "Define a path in this field using to the image field in this document at",
      " ",
      /* @__PURE__ */ jsx("code", { children: "options.hotspotImagePath" })
    ] }) }),
    imageHotspotOptions.pathRoot && !VALID_ROOT_PATHS.includes(imageHotspotOptions.pathRoot) && /* @__PURE__ */ jsxs(Feedback, { children: [
      'The supplied imageHotspotPathRoot "',
      imageHotspotOptions.pathRoot,
      '" is not valid, falling back to "document". Available values are "',
      VALID_ROOT_PATHS.join(", "),
      '".'
    ] }),
    props.renderDefault(props)
  ] });
}
const imageHotspotArrayPlugin = definePlugin({
  name: "image-hotspot-array",
  form: {
    components: {
      input: (props) => {
        var _a, _b;
        if (props.schemaType.jsonType === "array" && (_a = props.schemaType.options) != null && _a.imageHotspot) {
          const imageHotspotOptions = (_b = props.schemaType.options) == null ? void 0 : _b.imageHotspot;
          if (imageHotspotOptions)
            return /* @__PURE__ */ jsx(
              ImageHotspotArray,
              {
                ...props,
                imageHotspotOptions
              }
            );
        }
        return props.renderDefault(props);
      }
    }
  }
});
export {
  ImageHotspotArray,
  imageHotspotArrayPlugin
};
//# sourceMappingURL=index.mjs.map
